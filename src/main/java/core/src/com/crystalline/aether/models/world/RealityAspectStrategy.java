package com.crystalline.aether.models.world;

import com.badlogic.gdx.Gdx;
import com.crystalline.aether.models.Config;
import com.crystalline.aether.services.computation.Includer;
import com.crystalline.aether.services.utils.BufferUtils;
import com.crystalline.aether.services.utils.StringUtils;

import java.nio.FloatBuffer;

public class RealityAspectStrategy {
    /* TODO: Use Alpha value multiplier as a was to set resolution to handle enormous / extra small values */
    private static final String materialLibrary = StringUtils.readFileAsString(Gdx.files.internal("shaders/materialLibrary.fshader"));
    private static final String worldLibrary = StringUtils.readFileAsString(Gdx.files.internal("shaders/worldLibrary.fshader"));
    private static final String coordinatesLibrary = StringUtils.readFileAsString(Gdx.files.internal("shaders/coordinatesLibrary.fshader"));
    private static final String etherealLibrary = StringUtils.readFileAsString(Gdx.files.internal("shaders/ethLibrary.fshader"));
    private static final String elementalLibrary = StringUtils.readFileAsString(Gdx.files.internal("shaders/elmLibrary.fshader"));
    protected static final Includer baseIncluder = new Includer()
        .addSource(materialLibrary).addSource(worldLibrary).addSource(coordinatesLibrary)
        .addSource(etherealLibrary).addSource(elementalLibrary);

    protected static String buildKernel(String rawKernelCode, Includer includer){
        return includer.process(rawKernelCode);
    }

    /**
     * A texture image representing each cells intention to switch to another cell
     * - R: the offset code for the target, which is to be used in accordance with the coordinates of the source cell
     * - G: toApply bit --> whether to apply this change, or to try again in the next iteration
     *          0 - don't apply; 1 - a cell will switch with his cell; 2 - this cell will switch with another cell
     * - B: velocity tick for cells to be able to move with different speeds
     */
    public static float getOffsetCode(int x, int y, int chunkSize, FloatBuffer proposedChanges){
        return BufferUtils.get(x,y,chunkSize,Config.bufferCellSize,0, proposedChanges);
    }
    public static void setOffsetCode(int x, int y, int chunkSize, FloatBuffer proposedChanges, float value){
        BufferUtils.set(x,y, chunkSize,Config.bufferCellSize,0, proposedChanges, value);
    }
    public static float getToApply(int x, int y, int chunkSize, FloatBuffer proposedChanges){
        return BufferUtils.get(x,y, chunkSize,Config.bufferCellSize,1, proposedChanges);
    }
    public static void setToApply(int x, int y, int chunkSize, FloatBuffer proposedChanges, float value){
        BufferUtils.set(x,y,chunkSize,Config.bufferCellSize,1, proposedChanges, value);
    }
    public static int getVelocityTick(int x, int y, int chunkSize, FloatBuffer proposedChanges){
        return (int)BufferUtils.get(x,y,chunkSize,Config.bufferCellSize,2,proposedChanges);
    }
    public static void setVelocityTick(int x, int y, int chunkSize, FloatBuffer proposedChanges, float value){
        BufferUtils.set(x,y,chunkSize,Config.bufferCellSize,2,proposedChanges, value);
    }

    public static int getXFromOffsetCode(int x, int code){
        switch(code){
            case 1: case 8: case 7: return (x-1);
            case 2: case 0: case 6: return (x);
            case 3: case 4: case 5: return (x+1);
        }
        return x;
    }

    public static int getYFromOffsetCode(int y, int code){
        switch(code){
            case 7: case 6: case 5: return (y+1);
            case 8: case 0: case 4: return (y);
            case 1: case 2: case 3: return (y-1);
        }
        return y;
    }

    /**
     * Returns a code for the hardcoded directions based on the arguments
     * @param ox offset x -
     * @param oy offset y - the direction to which the direction should point
     * @return a code unique for any direction, generated by the given offsets
     */
    public static int getOffsetCode(int ox, int oy){
        if((ox < 0)&&(oy < 0)) return 1;
        if((ox == 0)&&(oy < 0)) return 2;
        if((ox > 0)&&(oy < 0)) return 3;
        if((ox > 0)&&(oy == 0)) return 4;
        if((ox > 0)/*&&(oy > 0)*/) return 5;
        if((ox == 0)&&(oy > 0)) return 6;
        if((ox < 0)&&(oy > 0)) return 7;
        if((ox < 0)/*&&(oy == 0)*/) return 8;
        return 0;
    }

    public static int getTargetX(int x, int y, int chunkSize, FloatBuffer buffer){
        return getXFromOffsetCode(x,(int)getOffsetCode(x,y,chunkSize,buffer));
    }

    public static int getTargetY(int x, int y, int chunkSize, FloatBuffer buffer){
        return getYFromOffsetCode(y,(int)getOffsetCode(x,y,chunkSize,buffer));
    }
}
